

# set the seed
set.seed( 123 )

#fit the original model
model <- lm( wt ~ mnumber + dwt + mparity + drace + mht + gestation, 
             data = base.model.dataset )

View( base.model.dataset )

#save predictions and residuals
pred <- predict( model )
resid <- resid( model )



lm.object <- model
B = 10
alpha = 0.05
i = 1

as.formula( lm.object$terms )

lm( as.formula( lm.object$terms ), data = resample )

bootstrap.fn <- function( lm.object, B = 10, alpha = 0.05 )
{
  set.seed( 123 )
  param.name <- c("Intercept", "Slope")
  n.obs <- nrow( lm.object$model )
  
  boot.coef <- matrix(NA, nrow = B + 1, ncol = 17)
  number.coefs <- matrix(17, nrow = B, ncol = 1)
  
  ci.bounds <- matrix(NA, nrow = 17, ncol = 2)
  
  for (i in 1:B)
  {
    resample.index <- sample( 1:n.obs, n.obs, replace = TRUE )
    resample <- lm.object$model[ resample.index, ]
    new.model <- lm( as.formula( lm.object$terms ), data = resample )
    num.coefs <- length( coef( new.model ) )
    if( num.coefs == 17 ){ 
      boot.coef[i,] <- coef( new.model ) 
    } else { number.coefs[i,] <- num.coefs   }
  }
  boot.coef[ B+1,] <- coef( lm.object )
  
  new.boot.coef <- boot.coef[ !rowSums( !is.finite( boot.coef ) ), ]
  
  actual.bootscompleted <- nrow( new.boot.coef )
  
  for(i in 1:17)
  {
    ci.bounds[i, ] <- round( quantile(  new.boot.coef[,i],
                                        probs =c( alpha / 2, ( 1 - alpha / 2 ) ) ),
                             digits = 6 )
  }

  return( list( ci.bounds = ci.bounds, 
                boot = boot.coef,
                refinedboot = new.boot.coef,
                numberofBootscompleted = actual.bootscompleted,
                coefs = number.coefs ) )
}


length( coef( new.model ) )

regular.boot <- bootstrap.fn( model, B = 999 )

regular.boot$ci.bounds

confint( model )

coef( new.model )

